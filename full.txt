==== ./cmd/server/main.go ====
package main

import (
	"bountyboard/cmd/server/servrun"
	"bountyboard/internal/domain/task"
	"encoding/gob"
	"log"
)

func init() {
	gob.Register(&task.Task{})
}

func main() {
	if err := servrun.Run(); err != nil {
		log.Fatal(err)
	}
}


==== ./cmd/server/servrun/run.go ====
package servrun

import (
	"bountyboard/internal/adapter/cache/memory"
	"bountyboard/internal/app/factory"
	"context"
	"errors"
	"html/template"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"syscall"
	"time"
)

var (
	cachePath = "task-cache.gob"
)

func Run() error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	tmpl, err := template.ParseFiles(
		filepath.Join("web", "templates", "layout.html"),
		filepath.Join("web", "templates", "tasks.html"),
	)
	if err != nil {
		return err
	}

	f := factory.NewFactory(ctx, "task-cache.gob", tmpl)

	app, err := f.BuildApp()
	if err != nil {
		return err
	}

	mux := http.NewServeMux()
	mux.HandleFunc("/", app.Handler.Main)
	mux.HandleFunc("/list", app.Handler.List)
	mux.HandleFunc("/add", app.Handler.Add)
	mux.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("./web/static"))))

	server := &http.Server{
		Addr:         ":8080",
		Handler:      mux,
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 15 * time.Second,
		IdleTimeout:  120 * time.Second,
	}

	go func() {
		slog.Info("Starting server", slog.String("addr", server.Addr))
		if err := server.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
			slog.Error(err.Error())
			os.Exit(1)
		}
	}()

	sign := make(chan os.Signal, 1)
	signal.Notify(sign, syscall.SIGINT, syscall.SIGTERM)
	<-sign

	ctxShutdown, cancelShutdown := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancelShutdown()

	if err := server.Shutdown(ctxShutdown); err != nil {
		slog.Error("server shutdown error", slog.String("err", err.Error()))
	} else {
		slog.Info("HTTP server shutdown completed")
	}

	if fc, ok := app.TaskService.Cache().(memory.FileCache); ok {
		if err = fc.SaveToFile(cachePath); err != nil {
			slog.Error("failed to save task cache", slog.String("err", err.Error()))
		} else {
			slog.Info("task cache saved")
		}
	}

	return nil
}


==== ./internal/adapter/cache/memory/memory.go ====
package memory

import (
	"bountyboard/internal/domain/task"
	"context"
	"encoding/gob"
	"log/slog"
	"os"
	"sync"
	"time"
)

type FileCache interface {
	task.Cache // Базовый интерфейс
	SaveToFile(filename string) error
	LoadFromFile(filename string) error
	RunAutoSave(ctx context.Context, filepath string, interval time.Duration)
	Janitor(ctx context.Context, interval time.Duration)
}

type cacheEntry struct {
	Tasks      []*task.Task
	Expiration time.Time
}

type TaskCache struct {
	data map[string]cacheEntry
	mu   sync.RWMutex
	ttl  time.Duration
}

func NewTaskCache(ttl time.Duration) *TaskCache {
	return &TaskCache{
		ttl:  ttl,
		data: make(map[string]cacheEntry),
	}
}

// Get возвращает кэшированные задачи для userID, если они существуют и не устарели
func (c *TaskCache) Get(userID string) ([]*task.Task, bool) {
	c.mu.RLock()
	entry, found := c.data[userID]
	c.mu.RUnlock()

	if !found {
		return nil, false
	}
	if time.Now().After(entry.Expiration) {
		// Кэш просрочен, но мы не удаляем его здесь
		return nil, false
	}
	return entry.Tasks, true
}

// Set сохраняет задачи в кэш с TTL
func (c *TaskCache) Set(userID string, tasks []*task.Task) {
	c.mu.Lock()
	defer c.mu.Unlock()

	c.data[userID] = cacheEntry{
		Tasks:      tasks,
		Expiration: time.Now().Add(c.ttl),
	}
}

// Invalidate удаляет кэш для конкретного пользователя
func (c *TaskCache) Invalidate(userID string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	delete(c.data, userID)
}

// Janitor чистит устаревший кэш
func (c *TaskCache) Janitor(ctx context.Context, interval time.Duration) {
	ticker := time.NewTicker(interval)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			c.cleanupExpired()
		case <-ctx.Done():
			return
		}
	}
}

func (c *TaskCache) cleanupExpired() {
	c.mu.Lock()
	defer c.mu.Unlock()

	now := time.Now()
	for userID, entry := range c.data {
		if now.After(entry.Expiration) {
			delete(c.data, userID)
		}
	}
}

func (c *TaskCache) SaveToFile(path string) error {
	c.mu.RLock()
	defer c.mu.RUnlock()

	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	enc := gob.NewEncoder(f)
	return enc.Encode(c.data)
}

func (c *TaskCache) LoadFromFile(path string) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	f, err := os.Open(path)
	if err != nil {
		return err
	}
	defer f.Close()

	dec := gob.NewDecoder(f)
	return dec.Decode(&c.data)
}

func (c *TaskCache) RunAutoSave(ctx context.Context, filepath string, interval time.Duration) {
	ticker := time.NewTicker(interval)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:

			if err := c.SaveToFile(filepath); err != nil {
				slog.Error("auto-save failed", slog.String("err", err.Error()))
			} else {
				slog.Debug("cache auto-saved", slog.String("path", filepath))
			}
		}
	}
}


==== ./internal/adapter/http/handlers/handler.go ====
package handlers

import (
	"bountyboard/internal/domain/task"
	"encoding/json"
	"html/template"
	"log/slog"
	"net/http"
)

type TaskHandler struct {
	service task.Service
	tmpl    *template.Template
}

func NewHandler(service task.Service, t *template.Template) *TaskHandler {
	return &TaskHandler{service: service, tmpl: t}
}

type Data struct {
	Title        string
	Description  template.HTML
	BountyAmount int
}

// Main выводит HTML-страницу с задачами
func (h *TaskHandler) Main(w http.ResponseWriter, r *http.Request) {
	userID := "demo" // TODO: заменить на реальный userID из аутентификации
	tasks, err := h.service.ListTasks(userID)
	if err != nil {
		slog.Error("failed to list tasks", slog.String("err", err.Error()))
		http.Error(w, "failed to load tasks", http.StatusInternalServerError)
		return
	}

	data := struct {
		Tasks []*task.Task
	}{
		Tasks: tasks,
	}

	if err = h.tmpl.Execute(w, data); err != nil {
		slog.Error("template execute error", slog.String("err", err.Error()))
		http.Error(w, "internal server error", http.StatusInternalServerError)
	}
}

// List возвращает JSON-массив задач
func (h *TaskHandler) List(w http.ResponseWriter, r *http.Request) {
	slog.Info("request", slog.String("url", r.URL.Path))
	userID := "demo" // TODO: заменить на реальный userID из аутентификации

	tasks, err := h.service.ListTasks(userID)
	if err != nil {
		http.Error(w, "failed to load tasks", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	if err = json.NewEncoder(w).Encode(tasks); err != nil {
		http.Error(w, "failed to encode tasks", http.StatusInternalServerError)
	}
}

// createTaskRequest структура для декодирования JSON-запроса
type createTaskRequest struct {
	UserID       string `json:"user_id"`
	Title        string `json:"title"`
	Description  string `json:"description"`
	BountyAmount int    `json:"bounty_amount"`
}

// Add создает новую задачу
func (h *TaskHandler) Add(w http.ResponseWriter, r *http.Request) {
	slog.Info("request", slog.String("url", r.URL.Path))
	if r.Method != http.MethodPost {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req createTaskRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		slog.Info("invalid request body", slog.String("err", err.Error()))
		http.Error(w, "invalid request body", http.StatusBadRequest)
		return
	}

	if req.UserID == "" || req.Title == "" {
		http.Error(w, "missing required fields", http.StatusBadRequest)
		return
	}

	if err := h.service.CreateTask(req.UserID, req.Title, req.Description, req.BountyAmount); err != nil {
		slog.Info("failed to create task", slog.String("err", err.Error()))
		http.Error(w, "failed to create task", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusCreated)
	_, _ = w.Write([]byte(`{"status":"created"}`))
}


==== ./internal/adapter/http/middleware/auth.go ====
package middleware


==== ./internal/adapter/http/middleware/logging.go ====
package middleware


==== ./internal/adapter/http/server/server.go ====
package server


==== ./internal/adapter/renderer/renderer.go ====
package renderer

// TODO: use in handlers

import (
	"bountyboard/internal/domain/task"
	"html/template"
	"net/http"
)

type Renderer struct {
	tmpl *template.Template
}

func NewRenderer(tmpl *template.Template) *Renderer {
	return &Renderer{tmpl: tmpl}
}

func (r *Renderer) RenderTasks(w http.ResponseWriter, tasks []*task.Task) {
	data := struct {
		Tasks []*task.Task
	}{
		Tasks: tasks,
	}

	if err := r.tmpl.Execute(w, data); err != nil {
		http.Error(w, "template error", http.StatusInternalServerError)
	}
}


==== ./internal/adapter/storage/in-memory/store.go ====
package inmemeory

import (
	"bountyboard/internal/domain/task"
	"sync"
)

type Repo struct {
	mu    sync.RWMutex
	tasks map[string]*task.Task
}

func NewRepo() *Repo {
	return &Repo{tasks: make(map[string]*task.Task)}
}

func (r *Repo) Create(t *task.Task) error {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.tasks[t.ID] = t
	return nil
}

func (r *Repo) ListByUser(userID string) ([]*task.Task, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	var res []*task.Task
	for _, t := range r.tasks {
		if t.UserID == userID {
			res = append(res, t)
		}
	}
	return res, nil
}

func (r *Repo) Complete(id string) error {
	r.mu.Lock()
	defer r.mu.Unlock()
	if t, ok := r.tasks[id]; ok {
		t.Done = true
	}
	return nil
}


==== ./internal/adapter/storage/postgres/store.go ====
package postgres


==== ./internal/app/app.go ====
package app

import (
	"bountyboard/internal/adapter/http/handlers"
	"bountyboard/internal/domain/task"
	"html/template"
)

type App struct {
	TaskService task.Service
	Handler     *handlers.TaskHandler
	Templates   *template.Template
}

func Setup(repo task.Repository, cache task.Cache, tmpl *template.Template) (*App, error) {
	// Создаем сервис из repo и cache
	service := task.New(repo, cache)

	// Создаем хендлер, передаем сервис и шаблоны
	handler := handlers.NewHandler(service, tmpl)

	return &App{
		TaskService: service,
		Handler:     handler,
		Templates:   tmpl,
	}, nil
}

/*
func Setup(ctx context.Context, cachePath string, tmpl *template.Template) (*App, error) {
	// репозиторий
	repo := inmemeory.NewRepo()
	slog.Info("init", slog.String("entry", "in-memory repo"))

	// кэш
	cache := memory.NewTaskCache(7 * 24 * time.Hour) // concrete type implementing FileCache
	go cache.Janitor(ctx, 10*time.Minute)
	go cache.RunAutoSave(ctx, cachePath, time.Hour)
	if err := cache.LoadFromFile(cachePath); err != nil {
		slog.Error("task cache error", slog.String("err", err.Error()))
	}

	// сервис
	service := task.New(repo, cache)
	slog.Info("init", slog.String("entry", "task service"))

	// хэндлер
	handler := handlers.NewHandler(service, tmpl)
	slog.Info("init", slog.String("entry", "task handler"))

	return &App{
		TaskService: service,
		Handler:     handler,
	}, nil
}
*/


==== ./internal/app/factory/factory.go ====
package factory

import (
	"bountyboard/internal/adapter/cache/memory"
	inmemeory "bountyboard/internal/adapter/storage/in-memory"
	"bountyboard/internal/app"
	"context"
	"html/template"
	"log/slog"
	"time"
)

type Factory struct {
	cachePath string
	ctx       context.Context
	tmpl      *template.Template
}

func NewFactory(ctx context.Context, cachePath string, tmpl *template.Template) *Factory {
	return &Factory{
		ctx:       ctx,
		cachePath: cachePath,
		tmpl:      tmpl,
	}
}

func (f *Factory) BuildApp() (*app.App, error) {
	// 1. Репозиторий
	repo := inmemeory.NewRepo()

	// 2. Кэш
	cache := memory.NewTaskCache(7 * 24 * time.Hour)
	go cache.Janitor(f.ctx, 10*time.Minute)
	go cache.RunAutoSave(f.ctx, f.cachePath, time.Hour)
	if err := cache.LoadFromFile(f.cachePath); err != nil {
		slog.Error("task cache error", slog.String("err", err.Error()))
	}

	// 3. Настраиваем и возвращаем App
	return app.Setup(repo, cache, f.tmpl)
}


==== ./internal/config/config.go ====
package config


==== ./internal/domain/task/entity.go ====
package task

type Task struct {
	ID           string `json:"id"`
	Title        string `json:"title"`
	Description  string `json:"description"`
	Done         bool   `json:"done"`
	BountyAmount int    `json:"bounty_amount"`
	UserID       string `json:"user_id"`
}


==== ./internal/domain/task/repository.go ====
package task

type Repository interface {
	Create(task *Task) error
	ListByUser(userID string) ([]*Task, error)
	Complete(id string) error
}

// Cache интерфейс кеша для задач
type Cache interface {
	Get(userID string) ([]*Task, bool)
	Set(userID string, tasks []*Task)
	Invalidate(userID string)
}


==== ./internal/domain/task/service.go ====
package task

import (
	"github.com/google/uuid"
)

type Service interface {
	CreateTask(userID, title, description string, amount int) error
	ListTasks(userID string) ([]*Task, error)
	CompleteTask(id string) error

	Cache() Cache
}

type service struct {
	repo  Repository
	cache Cache
}

func New(r Repository, c Cache) Service {
	return &service{repo: r, cache: c}
}

func (s *service) CreateTask(userID, title, description string, amount int) error {
	task := &Task{
		ID:           uuid.NewString(),
		Title:        title,
		Description:  description,
		Done:         false,
		BountyAmount: amount,
		UserID:       userID,
	}

	if err := s.repo.Create(task); err != nil {
		return err
	}

	if s.cache != nil {
		s.cache.Invalidate(userID)
	}

	return nil
}

func (s *service) ListTasks(userID string) ([]*Task, error) {
	if s.cache != nil {
		if cached, ok := s.cache.Get(userID); ok {
			return cached, nil
		}
	}

	tasks, err := s.repo.ListByUser(userID)
	if err != nil {
		return nil, err
	}

	if s.cache != nil {
		s.cache.Set(userID, tasks)
	}

	return tasks, nil
}

func (s *service) CompleteTask(id string) error {
	return s.repo.Complete(id)
}

func (s *service) Cache() Cache {
	return s.cache
}


==== ./pkg/ctext/ctext.go ====
package main

import (
	"bytes"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	p, _ := os.Getwd()
	fmt.Println(p)

	filename := "full.txt"
	err := DumpGoProject(".", filename, true)

	if err != nil {
		fmt.Println("Error:", err)
	}

	fmt.Printf("Code dump saved %s\n", filename)
}

// DumpGoProject собирает все .go файлы в модуле и сохраняет их в один текстовый файл.
func DumpGoProject(rootDir string, outputFile string, isFull bool) error {
	moduleRoot, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("cannot find go.mod: %w", err)
	}

	var buffer bytes.Buffer

	err = filepath.WalkDir(moduleRoot, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			if strings.HasPrefix(d.Name(), ".") || d.Name() == "vendor" {
				return filepath.SkipDir
			}
			return nil
		}
		if filepath.Ext(path) == ".go" {
			relPath, _ := filepath.Rel(moduleRoot, path)
			content, err := os.ReadFile(path)
			if err != nil {
				return fmt.Errorf("error reading %s: %w", path, err)
			}

			buffer.WriteString(fmt.Sprintf("==== ./%s ====\n", strings.Replace(relPath, "\\", "/", -1)))
			if isFull {
				buffer.Write(content)
			}
			buffer.WriteString("\n\n")
		}
		return nil
	})
	if err != nil {
		return err
	}

	return os.WriteFile(outputFile, buffer.Bytes(), 0644)
}

// findGoModRoot ищет корень модуля Go (директорию с go.mod).
func findGoModRoot(startDir string) (string, error) {
	dir := startDir
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("go.mod not found")
		}
		dir = parent
	}
}


==== ./pkg/prettylog/log.go ====
package prettylog

import (
	"context"
	"encoding/json"
	"github.com/fatih/color"
	"io"
	"log"
	"log/slog"
	"os"
)

type PrettyHandlerOptions struct {
	SlogOpts slog.HandlerOptions
}

type PrettyHandler struct {
	slog.Handler
	l *log.Logger
}

func (h *PrettyHandler) Handle(ctx context.Context, r slog.Record) error {
	level := r.Level.String() + ":"

	switch r.Level {
	case slog.LevelDebug:
		level = color.MagentaString(level)
	case slog.LevelInfo:
		level = color.BlueString(level)
	case slog.LevelWarn:
		level = color.YellowString(level)
	case slog.LevelError:
		level = color.RedString(level)
	}

	fields := make(map[string]interface{}, r.NumAttrs())
	r.Attrs(func(a slog.Attr) bool {
		fields[a.Key] = a.Value.Any()

		return true
	})

	//b, err := json.MarshalIndent(fields, "", "  ")
	b, err := json.Marshal(fields)
	if err != nil {
		return err
	}

	timeStr := r.Time.Format("[15:05:05.000]")
	msg := color.CyanString(r.Message)

	h.l.Println(timeStr, level, msg, color.WhiteString(string(b)))

	return nil
}

func NewPrettyHandler(
	out io.Writer,
	opts PrettyHandlerOptions,
) *PrettyHandler {
	h := &PrettyHandler{
		Handler: slog.NewJSONHandler(out, &opts.SlogOpts),
		l:       log.New(out, "", 0),
	}

	return h
}

func InitLogger(logLevel string) {
	opts := PrettyHandlerOptions{}

	switch logLevel {
	case "debug":
		opts.SlogOpts = slog.HandlerOptions{Level: slog.LevelDebug}
	default:
		opts.SlogOpts = slog.HandlerOptions{Level: slog.LevelInfo}
	}

	slog.SetDefault(slog.New(NewPrettyHandler(os.Stdout, opts)))
}


==== ./pkg/utils/utils.go ====
package utils

import (
	"bytes"
	"github.com/yuin/goldmark"
	"html/template"
)

func MdToHTML(md string) template.HTML {
	var buf bytes.Buffer
	if err := goldmark.Convert([]byte(md), &buf); err != nil {
		return template.HTML("<p><em>Error parsing description</em></p>")
	}
	return template.HTML(buf.String())
}


